<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

    <title>Procedural Macros Intro + Tips</title>
    <link rel="shortcut icon" href="./favicon.ico" />
    <link rel="stylesheet" href="./dist/reset.css" />
    <link rel="stylesheet" href="./dist/reveal.css" />
    <link rel="stylesheet" href="./dist/theme/black.css" id="theme" />
    <link rel="stylesheet" href="./css/highlight/ir-black.css" />

    <link rel="stylesheet" href="./assets//custom.css" />

  </head>
  <body>
    <div class="reveal">
      <div class="slides"><section  data-markdown><script type="text/template">

# Procedural Macros Intro + Tips

Let's make Rust procedural macros not scary

##### presented by Dan Aloni ([@DanAloni](https://twitter.com/DanAloni))

https://blog.aloni.org/rust-proc-macros-intro-and-tips

---

- Topics covered:
    - What are procedural macros
    - Useful crates to assist in implementation
    - Techniques to handle derive parsing
    - How to provide diagnostics for proc macro users
    - Techniques in debugging proc macros
    - Performance tuning

---

## First, what are macros

- In compile time, take in language tokens (e.g, `foo`, `+`, `[`), emit fully
valid Rust language items
- Purpose: boilerplate reduction
- Advance uses: extending the syntax ; embedding other languages

---

## Two main types of Rust macros

Declarative: using pattern matching

<!--- snippet-name: hello -->
```rust
macro_rules! hello {
    (3) => { println!("three!"); };
    ($e:expr) => { println!("expr: {}", $e); };
}
```

Procedural: compiled Rust code, AKA "proc macro"

<!--- snippet-name: hello-proc -->
<!--- snippet-template: proc-macro -->
```rust
#[proc_macro]
pub fn hello(_: TokenStream) -> TokenStream {
    todo!();
}
```
---

- Declarative: defined via pattern matching, can be used
inside the same crate that defines it
- Procedural:
    - A compiled Rust code for parsing any Rust token stream and generating Rust code
    - Has to be contained in a special `lib` crate
    - Shared library that `rustc` loads
    - Can run faster than declarative equivalent

---

## Types of proc macros

- Function-like:  `call!()`
- Attribute:  `#[attr]`
- Derive :  `#[Derive(Macro)]`

---

## Cargo.toml: proc macro crates

```toml
[package]
name = "hello"
version = "0.1.0"
edition = "2021"

[lib]
proc-macro = true # Special type of crate

[dependencies]
# For generating Rust code (and token streams in general)
quote = "1.*"
# For parsing Rust code (and token streams in general)
syn = { version = "1.0.*", features = ["full"]  }
proc-macro2 = "1" # Compiler glue
```

---

<!--- snippet-name: hello2 -->
```rust
macro_rules! hello {
    (3) => { println!("three!"); };
    ($e:expr) => { println!("expr: {}", $e); };
}
```

<!--- snippet-name: hello-proc2 -->
<!--- snippet-template: proc-macro2 -->

Re-implemented as a 'function-like' procedural macro:

```rust
use {proc_macro::TokenStream, quote::quote};

#[proc_macro]
pub fn hello(input: TokenStream) -> TokenStream {
    if let Ok(_) = syn::parse::<syn::Lit>(input.clone()) {
        return quote! { println!("three!"); }.into()
    }

    if let Ok(e) = syn::parse::<syn::Expr>(input) {
        return quote! { println!("expr: {}", #e); }.into()
    }

    panic!("nothing matched");
}
```

---

## The `syn` crate

* Industry standard parser for Rust code providing typed AST representation.
* It can also parse non-Rust code from Rust tokens using `Parse` trait impl.

---

## Example: `lazy_static`

```rust
lazy_static! {
    static ref WRD: Regex = Regex::new("[a-z]+").unwrap();
}
```

Let's parse this into:

```
struct LazyStatic {
    visibility: syn::Visibility,
    name: syn::Ident,
    ty: syn::Type,
    init: syn::Expr,
}
```


---

`lazy_static` parsing impl
```rust
impl Parse for LazyStatic {
    fn parse(input: ParseStream) -> Result<Self> {
        let visibility: Visibility = input.parse()?;
        input.parse::<Token![static]>()?;
        input.parse::<Token![ref]>()?;
        let name: Ident = input.parse()?;
        input.parse::<Token![:]>()?;
        let ty: Type = input.parse()?;
        input.parse::<Token![=]>()?;
        let init: Expr = input.parse()?;
        input.parse::<Token![;]>()?;
        Ok(LazyStatic { visibility, name, ty, init })
    }
}
```
---

```rust
#[proc_macro]
pub fn lazy_static(input: TokenStream) -> TokenStream {
    let LazyStatic {
        visibility,
        name,
        ty,
        init,
    } = parse_macro_input!(input as LazyStatic);

    ...
}
```

See the [rest of the example](https://github.com/dtolnay/syn/blob/fa1a855ea02661cf79e7d6af1e60b5a4a08698ac/examples/lazy-static/lazy-static/src/lib.rs) in `syn` repo

---

## The `quote` crate

- Provides the `quote` macro that generates a token stream. Supports interpolation of other token
streams or typed AST fragments in a syntax similar to declarative macros

```rust
let sometype = quote! { Vec<u64> };
quote! { let value: #sometype = vec![]; }
```

```rust
let list_of_stuff = vec![quote!{ 3 }, quote!{ 4 }];
quote! { let value = vec![#(#list_of_stuff),*]; }
```


---

* Using interpolation for composition of several other token stream generated previously by `quote!`:

```rust
let type_definition = quote! {...};
let methods = quote! {...};

let tokens = quote! {
    #type_definition
    #methods
};
```

---

### Syn macro `parse_quote!{}`

Like `quote` but outputs concrete AST types rather than token
stream. Assists in generating valid Rust

```rust
let name = quote!(v);
let ty = quote!(u8);

let stmt: Stmt = parse_quote! {
    let #name: #ty = Default::default();
};
```

---

### Derive macros

* A proc macro receiving a single type definition and output Rust code for that type, usually `impl`s

```rust
use mymacro::MyMacro;

#[derive(MyMacro)]
struct Foo {
    field: u16,
}
```


---

* Input is the token stream of the type definition, output
  are tokens appended in compilation
* Name of helper attributes can be specified

```rust
#[proc_macro_derive(MyMacro, attributes(mymacro))]
pub fn my_macro(input: TokenStream) -> TokenStream {
    // Parse the tokens into a syntax tree
    let ast: DeriveInput = syn::parse(input).unwrap();

    // Build the output
    quote! {
        /* ... */
    }.into()
}
```

---

## `syn`'s DeriveInput

```rust []
pub struct DeriveInput {
    pub attrs: Vec<Attribute>,
    pub vis: Visibility,
    pub ident: Ident,
    pub generics: Generics,
    pub data: Data,
}

pub enum Data {
    Struct(DataStruct),
    Enum(DataEnum),
    Union(DataUnion),
}
```

---

## `syn`'s DeriveInput
```rust [11]
pub struct DeriveInput {
    pub attrs: Vec<Attribute>,
    pub vis: Visibility,
    pub ident: Ident,
    pub generics: Generics,
    pub data: Data,
}

pub enum Data {
    Struct(DataStruct),
    Enum(DataEnum),
    Union(DataUnion),
}
```

---

```rust []
pub struct DataEnum {
    pub enum_token: Enum,
    pub brace_token: Brace,
    pub variants: Punctuated<Variant, Comma>,
}

pub struct Variant {
    pub attrs: Vec<Attribute>,
    pub ident: Ident,
    pub fields: Fields,
    pub discriminant: Option<(Eq, Expr)>,
}
```
---

```rust [4,10]
pub struct DataEnum {
    pub enum_token: Enum,
    pub brace_token: Brace,
    pub variants: Punctuated<Variant, Comma>,
}

pub struct Variant {
    pub attrs: Vec<Attribute>,
    pub ident: Ident,
    pub fields: Fields,
    pub discriminant: Option<(Eq, Expr)>,
}
```

---

```rust []
pub enum Fields {
    Named(FieldsNamed),
    Unnamed(FieldsUnnamed),
    Unit,
}

pub struct FieldsNamed {
    pub brace_token: Brace,
    pub named: Punctuated<Field, Comma>,
}
```

---

```rust [2,9]
pub enum Fields {
    Named(FieldsNamed),
    Unnamed(FieldsUnnamed),
    Unit,
}

pub struct FieldsNamed {
    pub brace_token: Brace,
    pub named: Punctuated<Field, Comma>,
}
```

---

```rust []
pub struct Field {
    pub attrs: Vec<Attribute>,
    pub vis: Visibility,
    pub ident: Option<Ident>,
    pub colon_token: Option<Colon>,
    pub ty: Type,
}
```

---

## Derive macro helper

- [`proc_macro_roids`](https://docs.rs/proc_macro_roids/latest/proc_macro_roids/) crate adds helper methods to `DeriveInput`
and related types

```rust
let ast = parse_macro_input!(input as DeriveInput);
let relevant_fields = ast.fields()
    .iter()
    .filter(|field| !field.is_phantom_data())
    .filter(|field| !field.contains_tag(
       &parse_quote!(super_derive), &parse_quote!(skip)));

```

---


### Single crate, multiple proc macros

A single proc macro crate can export several macros

```rust
#[proc_macro]
pub fn foo(_: TokenStream) -> TokenStream {
    ...
}

#[proc_macro]
pub fn bar(_: TokenStream) -> TokenStream {
    ...
}
```

---


## Trick: Export your derive macro

This is only available as `#[derive(Foo)]`:

```rust
#[proc_macro_derive(Foo, attributes(foo))]
pub fn foo(_: TokenStream) -> TokenStream {
    ...
}
```

Re-export this logic as a function-like macro:

```rust
#[proc_macro]
pub fn foo_derive(input: TokenStream) -> TokenStream {
    foo(input)
}
```

---

This way you can execute your derive on `std` types:

```rust
foo_derive!{
    struct Option {
        Some(x),
        None,
    }
}
```

Works on some cases, instead of writing an `impl` for them by hand


---

## Providing diagnostics

Using `panic!` is discouraged. For example:

```rust [7]
#[proc_macro_derive(MyMacro, attributes(mymacro))]
pub fn foo(input: TokenStream) -> TokenStream {
    let ast: DeriveInput = syn::parse(input).unwrap();
    match ast.data {
        Struct{..} => {}
        Enum{..} => {}
        _ => panic!("no support for this type kind"),
    }

    quote!{ }.into()
}

---

#### Result:
```
error: proc-macro derive panicked
 --> src/main.rs:4:10
  |
4 | #[derive(MyMacro)]
  |          ^^^^^^^
  |
  = help: message: no support for this type kind


---

- Use the `proc_macro_error` crate (see [guide](https://docs.rs/proc-macro-error/1.0.4/proc_macro_error/index.html#guide))

```rust [2,8-9]
#[proc_macro_derive(MyMacro, attributes(mymacro))]
#[proc_macro_error]
pub fn foo(input: TokenStream) -> TokenStream {
    let ast: DeriveInput = syn::parse(input).unwrap();
    match ast.data {
        Struct{..} => {}
        Enum{..} => {}
        _ => proc_macro_error::abort_call_site!(
            "no support for this type kind"),
    }

    quote!{ }.into()
}
```

---

#### Result:

```
error: no support for this type kind
 --> src/main.rs:4:10
  |
4 | #[derive(MyMacro)]
  |          ^^^^^^^
```
---

We can use pointers to user code, these are `Span`s:

```rust [2,8-11]
#[proc_macro_derive(MyMacro, attributes(mymacro))]
#[proc_macro_error]
pub fn foo(input: TokenStream) -> TokenStream {
    let ast: DeriveInput = syn::parse(input).unwrap();
    match ast.data {
        Struct{..} => {}
        Enum{..} => {}
        _ => proc_macro_error::abort!(
             ast.ident.span(),
                "mymacro: no support for deriving \
                 on this type kind"),
    }
    quote!{ }.into()
}
```

---

#### Result:

```
error: mymacro: no support for deriving on this type kind
 --> src/main.rs:5:7
  |
5 | union Test {
  |       ^^^^
```

---

## Debugging proc macros

* Sometimes during development your proc macro may generate
  a valid `TokenStream` but invalid Rust code
* Cannot use `cargo expand` in that case
* The `Display` impl for `TokenStream` and `syn` types are not
  good enough to eyeball the issue

---

```rust
// Pretty-print generated Rust code via rustfmt
fn rustfmt(code: TokenStream) -> String {
    let out: Option<&mut std::io::Sink> = None;

    let (_, result, _) = rustfmt::format_input(
        rustfmt::Input::Text(format!("{}", code)),
        &Default::default(), out)
        .expect("rustfmt failed");

    format!("{}", result.first()
        .expect("rustfmt returned no code").1)
}
```

---

```rust
// Save derivations to file for debug
#[proc_macro_derive(MyMacro, attributes(mymacro))]
pub fn my_macro(input: TokenStream) -> TokenStream {
    let input: DeriveInput = syn::parse(input).unwrap();
    let code: proc_macro2::TokenStream = todo!();

    if let Ok(dir) = std::env::var("DERIVE_SAVE_DIR") {
        let dir = Path::new(dir.as_str())
           .join(format!("derive_mymacro_{}.rs",
            &input.ident);
        tokens_to_rustfmt_file(&dir, &code);
    }
    code.into()
}
```

---

## Macro hygiene

- Declarative macros cannot shadow definitions in context. Example:

```
macro_rules! hello {
    () => { let x = 2; };
}
```

- `hello!()` uses cannot see `x` in scope
- What about proc macros hygiene? [Rust issue 54727 (2018-)](https://github.com/rust-lang/rust/issues/54727), still open Dec 2022

---

Hygiene synthesis: isolate generated code to module

```rust
#[proc_macro]
pub fn my_macro(input: TokenStream) -> TokenStream {
    let unique_id = todo!();

    quote! {
        mod #unique_id {
            use other_crate::*;

            // pub NewDefinition here
        }
        use #unique_id::NewDefinition;
    }.into()
}
```
---

# Performance

- The Rust compiler is optimized
- Proc macro run more than they change
- In dev builds, your macro binary code should be too:

```toml
[profile.dev.package.myprocmacro]
opt-level = 3
```

---


### Resources

- [Procedural Macros - The Rust Reference](https://doc.rust-lang.org/reference/procedural-macros.html)
- [dtolnay/proc-macro-workshop: Learn to write Rust procedural macros](https://github.com/dtolnay/proc-macro-workshop) (2019)
- [Procedural macros under the hood: Part I](https://blog.jetbrains.com/rust/2022/03/18/procedural-macros-under-the-hood-part-i/) (2022)
- [Procedural macros under the hood: Part II](https://blog.jetbrains.com/rust/2022/07/07/procedural-macros-under-the-hood-part-ii/) (2022)
</script></section></div>
    </div>

    <script src="./dist/reveal.js"></script>

    <script src="./plugin/markdown/markdown.js"></script>
    <script src="./plugin/highlight/highlight.js"></script>
    <script src="./plugin/zoom/zoom.js"></script>
    <script src="./plugin/notes/notes.js"></script>
    <script src="./plugin/math/math.js"></script>
    <script>
      function extend() {
        var target = {};
        for (var i = 0; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (source.hasOwnProperty(key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      }

      // default options to init reveal.js
      var defaultOptions = {
        controls: true,
        progress: true,
        history: true,
        center: true,
        transition: 'default', // none/fade/slide/convex/concave/zoom
        plugins: [
          RevealMarkdown,
          RevealHighlight,
          RevealZoom,
          RevealNotes,
          RevealMath
        ]
      };

      // options from URL query string
      var queryOptions = Reveal().getQueryHash() || {};

      var options = extend(defaultOptions, {"transition":"fade"}, queryOptions);
    </script>


    <script>
      Reveal.initialize(options);
    </script>
  </body>
</html>
